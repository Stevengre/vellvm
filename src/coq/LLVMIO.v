(* -------------------------------------------------------------------------- *
 *                     Vellvm - the Verified LLVM project                     *
 *                                                                            *
 *     Copyright (c) 2017 Steve Zdancewic <stevez@cis.upenn.edu>              *
 *                                                                            *
 *   This file is distributed under the terms of the GNU General Public       *
 *   License as published by the Free Software Foundation, either version     *
 *   3 of the License, or (at your option) any later version.                 *
 ---------------------------------------------------------------------------- *)

Require Import ZArith List String Omega.
Require Import Vellvm.Classes Vellvm.Util Vellvm.Trace.
Require Import Vellvm.MemoryAddress.
Require Import Vellvm.DynamicValues.

Set Implicit Arguments.
Set Contextual Implicit.

Inductive dtyp : Set :=
| DTYPE_I (sz:Z)
| DTYPE_Pointer
| DTYPE_Void
| DTYPE_Half
| DTYPE_Float
| DTYPE_Double
| DTYPE_X86_fp80
| DTYPE_Fp128
| DTYPE_Ppc_fp128
| DTYPE_Metadata
| DTYPE_X86_mmx
| DTYPE_Array (sz:Z) (t:dtyp)
| DTYPE_Struct (fields:list dtyp)
| DTYPE_Packed_struct (fields:list dtyp)
| DTYPE_Opaque
| DTYPE_Vector (sz:Z) (t:dtyp)     (* t must be integer, floating point, or pointer type *)
.


Module Type LLVM_INTERACTIONS (ADDR : MemoryAddress.ADDRESS).

Global Instance eq_dec_addr : eq_dec ADDR.addr := ADDR.addr_dec.

  

(* The set of dynamic types manipulated by an LLVM program.  Mostly
   isomorphic to LLVMAst.typ but
     - pointers have no further detail
     - identified types are not allowed
   Questions:
     - What to do with Opaque?
*)

Module DV := DynamicValues.DVALUE(ADDR).
Export DV.

Existing Instance ADDR.fp.
Existing Instance ADDR.mp.

Definition state := ADDR.state.

Definition T := fun (A:Type) => (state * A)%type.

(* Global Instance fmap_T : Functor T := fun {A B} (f:A->B) (x:T A) => fun s => let '(s', a) := x s in (s', f a). *)

  (* IO Interactions for the LLVM IR *)
  Inductive IO : Type -> Type :=
  | Alloca : forall (s:state) (t:dtyp), (IO (T dvalue))
  | Load   : forall (s:state) (t:dtyp) (a:dvalue), (IO (T dvalue))
  | Store  : forall (s:state) (a:dvalue) (v:dvalue), (IO (T unit))
  | GEP    : forall (s:state) (t:dtyp) (v:dvalue) (vs:list dvalue), (IO (T dvalue))
  | ItoP   : forall (s:state) (i:dvalue), (IO (T dvalue))
  | PtoI   : forall (s:state) (a:dvalue), (IO (T dvalue))
  | Call   : forall (s:state) (t:dtyp) (f:string) (args:list dvalue), (IO (T dvalue))
.    



(* Trace of events generated by a computation. *)
Definition Trace X := state -> ADDR.P (M IO (state * X)).
Hint Unfold Trace.

Definition Trace_map {A B} (f : A -> B) (s : Trace A) : Trace B :=
  fun st => fmap (fmap (fun '(st, a) => (st, f a))) (s st).

Global Instance functor_trace : Functor Trace := (fun A B => @Trace_map A B).

Definition Trace_ret {A} (x:A) : Trace A :=
  fun st => mret (Ret (st, x)).

Definition Trace_bind {A} {B} (t:Trace A) (f : A -> Trace B) : Trace B :=
  fun st => mbind (t st) (fun u =>  ).

                                                   
Global Instance monad_trace : (@Monad Trace) (functor_trace) := { mret X x := Trace_ret x; mbind := (fun A B => @Trace_bind A B)}.
Global Instance exn_trace : (@ExceptionMonad string Trace _ _) :=
  {| raise := fun _ s => fun _ => Err s;
     catch := fun _ e k => fun st => match (e st) with
                        | Err e => k e st
                        | _ => (e st)
                        end
  |}.
(* Trace Utilities ---------------------------------------------------------- *)

(* Lift the error monad into the trace monad. *)
Definition lift_err_d {A X} (m:err A) (f: A -> Trace X) : Trace X :=
  match m with
  | inl s => raise s
  | inr b => f b
  end.

Notation "'do' x <- m ; f" := (lift_err_d m (fun x => f)) 
                               (at level 200, x ident, m at level 100, f at level 200).


End LLVM_INTERACTIONS.

  
Module Make(ADDR : MemoryAddress.ADDRESS) <: LLVM_INTERACTIONS(ADDR).
(* The set of dynamic types manipulated by an LLVM program.  Mostly
   isomorphic to LLVMAst.typ but
     - pointers have no further detail
     - identified types are not allowed
   Questions:
     - What to do with Opaque?
*)
Include LLVM_INTERACTIONS(ADDR).
End Make.

